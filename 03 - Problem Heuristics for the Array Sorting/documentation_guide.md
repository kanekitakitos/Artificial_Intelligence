# AI Documentation Guide: Classes and Methods

This guide provides a comprehensive overview of how to document Java classes and methods so that an AI can understand their purpose, design, and implementation details. We will use examples from the Array Sorting project to illustrate these principles.

## 1. Class Documentation

Class documentation should provide a high-level overview of the class's role in the system.

### 1.1. Class Header

The class header should include:

*   **A brief summary** of the class's purpose.
*   **Key design principles or patterns** used (e.g., immutability, strategy pattern).
*   **Relationships** with other important classes using the `@see` tag.
*   **Author and version** information.

**Example: `ArrayCfg.java`**

```java
/**
 * Represents an immutable configuration of the integer array sorting problem.
 *
 * This class implements the {@link Ilayout} interface, defining the state representation,
 * successor generation, and goal checking for the search algorithm. It is designed to be
 * immutable to ensure that states cannot be accidentally modified during the search process.
 *
 * <h3>Key Implementation Details</h3>
 * <h4>Immutability</h4>
 * <p>
 * Immutability is a core design principle of this class. It is achieved by:
 * </p>
 * <ul>
 *   <li>Declaring the class as {@code final} to prevent extension.</li>
 *   <li>Making all fields {@code final}.</li>
 *   <li>Creating defensive copies of the internal array in the {@link #children()} method before modification.</li>
 * </ul>
 *
 * <h4>Successor Generation</h4>
 * <p>
 * The {@link #children()} method generates successors in a specific, deterministic order as required by the problem
 * statement: the first element is swapped with all elements to its right, then the second with all to its right, and so on.
 * </p>
 *
 * @see Ilayout
 * @see AStarSearch
 * @see GSolver
 * @author Brandon Mejia
 * @version 2024-10-15
 */
public final class ArrayCfg implements Ilayout {
    // ...
}
```

### 1.2. Inner Classes

If a class has a significant inner class (especially a private one), document its purpose and why it's designed as an inner class.

**Example: The `Heuristic` inner class in `ArrayCfg.java`**

```java
/**
 * A private, static helper class that encapsulates the entire heuristic calculation.
 * <p>
 * This class acts as a stateless calculator that uses a sophisticated hybrid strategy based on
 * <b>permutation decomposition into disjoint cycles</b>. The goal is to compute a very tight
 * lower-bound cost estimate for sorting the array, which makes the A* search extremely efficient.
 *
 * <h3>Heuristic Strategy</h3>
 * The permutation required to transform the current state into the goal state is decomposed into
 * cycles...
 *
 * @author Brandon Mejia
 * @see #compute()
 */
private static final class Heuristic {
    // ...
}
```

## 2. Method Documentation

Method documentation should be clear and concise, explaining what the method does, its parameters, and what it returns.

### 2.1. Method Summary

*   **A clear description** of the method's purpose.
*   **`@param` tags** for each parameter, explaining its role.
*   **`@return` tag** describing the return value.
*   **`@throws` tag** if the method can throw exceptions.

### 2.2. Implementation Details

For complex methods, add a `<p>` tag to explain the algorithm or implementation strategy.

**Example: `children()` method in `ArrayCfg.java`**

```java
/**
 * Generates all unique successor states (children) from the current state.
 * <p>
 * The successors are generated by swapping every unique pair of integers in the array.
 * The order of generation follows the assignment's specification: the first element
 * is swapped with all elements to its right, then the second element with all elements
 * to its right, and so on.
 *
 * @return A list of child layouts. The list is unmodifiable to preserve immutability.
 */
@Override
public List<Ilayout> children() {
    // ...
}
```

**Example: `getH()` method in `ArrayCfg.java`**

```java
/**
 * Calculates the heuristic value (h) for the A* algorithm.
 * <p>
 * This method delegates the complex calculation to a dedicated, private static helper class,
 * {@link Heuristic}, which implements a highly accurate and admissible heuristic based on
 * permutation cycle decomposition. This encapsulation keeps the {@code ArrayCfg} class
 * focused on representing a state, while the {@code Heuristic} class handles the
 * complex algorithmic logic.
 *
 * @see Heuristic
 */
@Override
public double getH(Ilayout goal) {
    // ...
}
```

**Example: `createFringe()` method in `AStarSearch.java`**

```java
/**
 * Creates the fringe for A* Search.
 *
 * @return A {@link PriorityQueue} that orders states by f(n) = g(n) + h(n).
 * Tie-breaking is done using the sequence ID.
 */
@Override
protected Queue<State> createFringe() {
    // ...
}
```

By following these guidelines, you can create documentation that is not only helpful for human developers but also perfectly understandable for an AI, enabling it to assist you more effectively.
