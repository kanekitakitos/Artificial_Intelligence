package core;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Represents an immutable configuration of the integer array sorting problem.
 *
 * This class implements the {@link Ilayout} interface, defining the state representation,
 * successor generation, and goal checking for the search algorithm. It is designed to be
 * immutable to ensure that states cannot be accidentally modified during the search process.
 *
 * <h3>Key Implementation Details</h3>
 * <h4>Immutability</h4>
 * <p>
 * Immutability is a core design principle of this class. It is achieved by:
 * </p>
 * <ul>
 *   <li>Declaring the class as {@code final} to prevent extension.</li>
 *   <li>Making all fields {@code final}.</li>
 *   <li>Creating defensive copies of the internal array in the {@link #children()} method before modification.</li>
 * </ul>
 *
 * <h4>Successor Generation</h4>
 * <p>
 * The {@link #children()} method generates successors in a specific, deterministic order as required by the problem
 * statement: the first element is swapped with all elements to its right, then the second with all to its right, and so on.
 * </p>
 *
 * @see Ilayout
 * @see GSolver
 * @author Brandon Mejia
 * @version 2025-09-30
 */
public final class ArrayCfg implements Ilayout {

    private final int[] data;
    /** The cost of the single swap that produced this state (0 for the initial state). */
    private final int cost;

    /**
     * Constructs an ArrayCfg from a space-separated string of integers.
     * This constructor is typically used for creating the initial and goal states.
     *
     * @param s The input string (e.g., "9 7 8").
     * @throws IllegalArgumentException if the input string is null or empty.
     */
    public ArrayCfg(String s)
    {
        if (s == null || s.trim().isEmpty()) {
            throw new IllegalArgumentException("Input string cannot be null or empty.");
        }
        // Split on any sequence of one or more whitespace characters for robustness.
        this.data = Arrays.stream(s.trim().split("\\s+"))
                .mapToInt(Integer::parseInt)
                .toArray();
        this.cost = 0;
    }

    /**
     * Private constructor used internally to create successor (child) states.
     *
     * @param data The new array configuration for the child.
     * @param cost The cost of the single swap that created this child state.
     */
    private ArrayCfg(int[] data, int cost) {
        this.data = data; // Assumes the caller provides a new array instance.
        this.cost = cost;
    }

    /**
     * Generates all unique successor states (children) from the current state.
     * <p>
     * The successors are generated by swapping every unique pair of integers in the array.
     * The order of generation follows the assignment's specification: the first element
     * is swapped with all elements to its right, then the second element with all elements
     * to its right, and so on.
     *
     * @return A list of child layouts. The list is unmodifiable to preserve immutability.
     */
    @Override
    public List<Ilayout> children() {
        int n = data.length;
        if (n < 2) return Collections.emptyList();

        // Pre-allocate list capacity for performance. The number of unique swaps is n*(n-1)/2.
        List<Ilayout> children = new ArrayList<>(n * (n - 1) / 2);

        // Generate all unique swaps in the specified order.
        for (int i = 0; i < n - 1; i++)
        {
            for (int j = i + 1; j < n; j++)
            {
                // Create a defensive copy of the data array to ensure the parent state remains immutable.
                int[] childData = Arrays.copyOf(data, n);

                // Perform the swap in the new child's array.
                int tmp = childData[i];
                childData[i] = childData[j];
                childData[j] = tmp;

                // Calculate the cost of this specific swap based on the parent's values.
                int swapCost = calculateCost(data[i], data[j]);

                // Create and add the new child state to the list.
                children.add(new ArrayCfg(childData, swapCost));
            }
        }

        // Return an unmodifiable view of the list to enforce immutability.
        return Collections.unmodifiableList(children);
    }

    /**
     * Calculates the cost of swapping two integers based on their parity.
     * <ul>
     *   <li>Swapping two even integers: cost 2</li>
     *   <li>Swapping two odd integers: cost 20</li>
     *   <li>Swapping one even and one odd integer: cost 11</li>
     * </ul>
     *
     * @param a The first integer.
     * @param b The second integer.
     * @return The calculated cost of the swap.
     */
    private static int calculateCost(int a, int b) {
        // Explicitly define 0 as even. For other numbers, use bitwise AND for an efficient parity check
        // that works correctly for both positive and negative integers.
        boolean aEven = (a == 0) || ((a & 1) == 0);
        boolean bEven = (b == 0) || ((b & 1) == 0);

        if (aEven == bEven) { // Both have the same parity
            return aEven ? 2 : 20; // If aEven is true, both are even (cost 2), else both are odd (cost 20)
        } else { // Mixed parity
            return 11;
        }
    }

    /**
     * Checks if the current layout is the goal layout.
     *
     * @param l The layout to compare against.
     * @return {@code true} if the layouts are identical, {@code false} otherwise.
     */
    @Override
    public boolean isGoal(Ilayout l) {
        if (l == null || getClass() != l.getClass()) return false;
        return Arrays.equals(this.data, ((ArrayCfg) l).data);
    }

    /**
     * Gets the cost of the single step (swap) that produced this layout.
     * For the initial state, this cost is 0.
     *
     * @return The cost of the last move.
     */
    @Override
    public double getK() {
        return  this.cost;
    }

    /**
     * Calculates the heuristic value (h) for the A* algorithm.
     * <p>
     * This is a highly sophisticated and admissible heuristic that provides a very tight lower-bound
     * estimate of the cost to sort the array. It uses a hybrid strategy based on the mathematical
     * concept of <b>permutation cycle decomposition</b>, making the A* search extremely efficient.
     * The calculation involves the following steps:
     * </p>
     * <ol>
     *   <li><b>Mapping:</b> It first determines the target position for each element in the current
     *       layout relative to the goal layout, correctly handling duplicate numbers.</li>
     *   <li><b>Cycle Decomposition:</b> The permutation is broken down into disjoint cycles. For example,
     *       if element `A` is in `B`'s spot, `B` in `C`'s spot, and `C` in `A`'s spot, they form a 3-cycle.</li>
     *   <li><b>Hybrid Cost Calculation:</b> The cost for resolving each cycle is estimated based on its size:
     *     <ul>
     *       <li><b>2-Cycles:</b> The exact cost of the single swap required is calculated.</li>
     *       <li><b>Small Cycles (3-5 elements):</b> A brute-force search is performed to find the
     *           <em>true optimal cost</em> to resolve the cycle. It explores all possible sequences of `k-1`
     *           swaps within the cycle's elements.</li>
     *       <li><b>Large Cycles (>5 elements):</b> To avoid combinatorial explosion, a fast and admissible
     *           greedy estimation is used. The elements from all large cycles are pooled, and the cost
     *           is estimated by repeatedly simulating the cheapest possible swap type (even-even, etc.).</li>
     *     </ul>
     *   </li>
     * </ol>
     * <p>
     * This heuristic remains <b>admissible</b> because it calculates the exact or optimal cost for small
     * subproblems and uses a conservative, best-case greedy estimate for larger ones. At no point does
     * it overestimate the true minimum cost.
     * </p>
     * <ul>
     *     <li><b>Time Complexity:</b> O(n), where n is the number of elements in the array. Each step
     *     (mapping, cycle decomposition, greedy pairing) is linear.</li>
     *     <li><b>Space Complexity:</b> O(n), due to the storage required for the position maps and visited arrays.</li>
     * </ul>
     *
     * @param goal The goal layout to compare against.
     * @return The estimated cost to reach the goal.
     */
    @Override
    public double getH(Ilayout goal) {
        if (!(goal instanceof ArrayCfg)) return Double.POSITIVE_INFINITY;
        ArrayCfg goalCfg = (ArrayCfg) goal;

        int n = data.length;
        if (goalCfg.data.length != n) return Double.POSITIVE_INFINITY;

        // 1) Map goal values -> queue of positions (handles duplicates)
        java.util.Map<Integer, java.util.ArrayDeque<Integer>> posMap = new java.util.HashMap<>();
        for (int j = 0; j < n; j++) {
            posMap.computeIfAbsent(goalCfg.data[j], k -> new java.util.ArrayDeque<>()).addLast(j);
        }

        // 2) Build targetIndex: where the element at i should go in the goal
        int[] targetIndex = new int[n];
        for (int i = 0; i < n; i++) {
            java.util.ArrayDeque<Integer> q = posMap.get(data[i]);
            if (q == null || q.isEmpty()) {
                // multisets differ -> unreachable goal mapping
                return Double.POSITIVE_INFINITY;
            }
            targetIndex[i] = q.removeFirst();
        }

        // 3) Decompose permutation into cycles and process each cycle
        boolean[] visited = new boolean[n];
        double heuristic = 0.0;

        // We'll accumulate counts for the fallback (cycles > 5)
        int totalSwapsNeededFallback = 0;
        int evenRemFallback = 0;
        int oddRemFallback = 0;

        for (int i = 0; i < n; i++) {
            if (visited[i] || targetIndex[i] == i) {
                visited[i] = true;
                continue;
            }

            // Collect the cycle: positions and their current values and goal values
            int cur = i;
            java.util.ArrayList<Integer> cyclePos = new java.util.ArrayList<>();
            java.util.ArrayList<Integer> cycleVals = new java.util.ArrayList<>();
            java.util.ArrayList<Integer> cycleGoalVals = new java.util.ArrayList<>();

            while (!visited[cur]) {
                visited[cur] = true;
                cyclePos.add(cur);
                cycleVals.add(data[cur]);
                cycleGoalVals.add(goalCfg.data[cur]);
                cur = targetIndex[cur];
            }

            int k = cyclePos.size();
            if (k <= 1) continue;

            if (k == 2) {
                // Exact cost for 2-cycle (one swap)
                int a = cycleVals.get(0);
                int b = cycleVals.get(1);
                heuristic += calculateCost(a, b);
            } else if (k <= 5) {
                // Brute-force all sequences of (k-1) swaps among the k positions.
                // Each swap is an unordered pair (p,q) with p<q in [0..k-1] index space for the cycle.
                int pairs = k * (k - 1) / 2;
                // Build list of all pair index pairs (indices into cycle arrays)
                java.util.ArrayList<int[]> pairList = new java.util.ArrayList<>(pairs);
                for (int a = 0; a < k - 1; a++) {
                    for (int b = a + 1; b < k; b++) {
                        pairList.add(new int[]{a, b});
                    }
                }

                // We need to generate all sequences of length (k-1) where each element is an index into pairList.
                int steps = k - 1;
                long sequences = 1;
                for (int s = 0; s < steps; s++) sequences *= pairList.size(); // safe: at most 10^4 for k=5

                double bestCost = Double.POSITIVE_INFINITY;

                // Iterate sequences using mixed-radix counting (index vector)
                int base = pairList.size();
                int[] idx = new int[steps];
                for (long seq = 0; seq < sequences; seq++) {
                    // simulate applying the sequence of swaps on a local copy of the cycle values
                    int[] curVals = new int[k];
                    for (int t = 0; t < k; t++) curVals[t] = cycleVals.get(t);

                    double costSum = 0.0;
                    for (int step = 0; step < steps; step++) {
                        int pairIndex = idx[step];
                        int p = pairList.get(pairIndex)[0];
                        int q = pairList.get(pairIndex)[1];

                        // values at the time of swap
                        int va = curVals[p];
                        int vb = curVals[q];
                        costSum += calculateCost(va, vb);

                        // perform swap
                        int tmp = curVals[p];
                        curVals[p] = curVals[q];
                        curVals[q] = tmp;

                        // small early pruning: if costSum already >= bestCost, stop this sequence
                        if (costSum >= bestCost) break;
                    }

                    // After the sequence, check if positions are in goal values
                    boolean matches = true;
                    if (costSum < bestCost) {
                        for (int t = 0; t < k; t++) {
                            if (curVals[t] != cycleGoalVals.get(t)) {
                                matches = false;
                                break;
                            }
                        }
                        if (matches) {
                            bestCost = costSum;
                        }
                    }

                    // increment mixed-radix index array
                    for (int p = steps - 1; p >= 0; p--) {
                        idx[p]++;
                        if (idx[p] < base) break;
                        idx[p] = 0;
                    }
                }

                // If for some reason no sequence solved the cycle (shouldn't happen), fallback to relaxed idea:
                if (bestCost == Double.POSITIVE_INFINITY) {
                    // fall back to conservative estimate: count parities and add (k-1) as swaps
                    int evenCount = 0, oddCount = 0;
                    for (int v : cycleVals) {
                        boolean ev = (v == 0) || ((v & 1) == 0);
                        if (ev) evenCount++; else oddCount++;
                    }
                    // consume greedily (same as fallback below)
                    int swapsNeeded = k - 1;
                    for (int s = 0; s < swapsNeeded; s++) {
                        if (evenCount >= 2) {
                            bestCost = (bestCost == Double.POSITIVE_INFINITY ? 0 : bestCost) + 2;
                            evenCount -= 2;
                        } else if (evenCount >= 1 && oddCount >= 1) {
                            bestCost = (bestCost == Double.POSITIVE_INFINITY ? 0 : bestCost) + 11;
                            evenCount -= 1;
                            oddCount -= 1;
                        } else if (oddCount >= 2) {
                            bestCost = (bestCost == Double.POSITIVE_INFINITY ? 0 : bestCost) + 20;
                            oddCount -= 2;
                        } else {
                            // conservative: break (shouldn't happen)
                            break;
                        }
                    }
                    if (bestCost == Double.POSITIVE_INFINITY) bestCost = 0.0;
                }

                heuristic += bestCost;
            } else {
                // For large cycles we use the relaxed/guloso parities approach (admissible and O(n))
                int evenCount = 0, oddCount = 0;
                for (int v : cycleVals) {
                    boolean ev = (v == 0) || ((v & 1) == 0);
                    if (ev) evenCount++; else oddCount++;
                }
                int swapsNeeded = k - 1;
                totalSwapsNeededFallback += swapsNeeded;
                evenRemFallback += evenCount;
                oddRemFallback += oddCount;
            }
        }

        // 4) handle aggregated fallback swaps (from cycles of size > 5)
        for (int s = 0; s < totalSwapsNeededFallback; s++) {
            if (evenRemFallback >= 2) {
                heuristic += 2;
                evenRemFallback -= 2;
            } else if (evenRemFallback >= 1 && oddRemFallback >= 1) {
                heuristic += 11;
                evenRemFallback -= 1;
                oddRemFallback -= 1;
            } else if (oddRemFallback >= 2) {
                heuristic += 20;
                oddRemFallback -= 2;
            } else {
                // no more pairs available (should be rare); break conservatively
                break;
            }
        }

        return heuristic;
    }

    /**
     * Returns a string representation of the layout.
     * The integers are separated by a single space.
     *
     * @return A space-separated string of the array's contents.
     */
    @Override
    public String toString() {
        return Arrays.stream(data)
                .mapToObj(String::valueOf)
                .collect(Collectors.joining(" "));
    }

    /**
     * Compares this layout with another object for equality.
     * Two {@code ArrayCfg} objects are considered equal if their underlying integer arrays
     * have the same content in the same order.
     *
     * @param o The object to compare with.
     * @return {@code true} if the objects are equal, {@code false} otherwise.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ArrayCfg other = (ArrayCfg) o;
        return Arrays.equals(this.data, other.data);
    }

    /**
     * Returns a hash code for this layout.
     * The hash code is based on the contents of the integer array, making it consistent
     * with the {@link #equals(Object)} method.
     *
     * @return The hash code for this layout.
     */
    @Override
    public int hashCode() {
        return Arrays.hashCode(data);
    }
}
