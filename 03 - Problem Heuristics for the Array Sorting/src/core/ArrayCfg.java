package core;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayDeque;

/**
 * Represents an immutable configuration of the integer array sorting problem.
 *
 * This class implements the {@link Ilayout} interface, defining the state representation,
 * successor generation, and goal checking for the search algorithm. It is designed to be
 * immutable to ensure that states cannot be accidentally modified during the search process.
 *
 * <h3>Key Implementation Details</h3>
 * <h4>Immutability</h4>
 * <p>
 * Immutability is a core design principle of this class. It is achieved by:
 * </p>
 * <ul>
 *   <li>Declaring the class as {@code final} to prevent extension.</li>
 *   <li>Making all fields {@code final}.</li>
 *   <li>Creating defensive copies of the internal array in the {@link #children()} method before modification.</li>
 * </ul>
 *
 * <h4>Successor Generation</h4>
 * <p>
 * The {@link #children()} method generates successors in a specific, deterministic order as required by the problem
 * statement: the first element is swapped with all elements to its right, then the second with all to its right, and so on.
 * </p>
 *
 * @see Ilayout
 * @see GSolver
 * @author Brandon Mejia
 * @version 2025-09-30
 */
public final class ArrayCfg implements Ilayout {

    private final int[] data;
    /** The cost of the single swap that produced this state (0 for the initial state). */
    private final int cost;

    /**
     * Constructs an ArrayCfg from a space-separated string of integers.
     * This constructor is typically used for creating the initial and goal states.
     *
     * @param s The input string (e.g., "9 7 8").
     * @throws IllegalArgumentException if the input string is null or empty.
     */
    public ArrayCfg(String s)
    {
        if (s == null || s.trim().isEmpty()) {
            throw new IllegalArgumentException("Input string cannot be null or empty.");
        }
        // Split on any sequence of one or more whitespace characters for robustness.
        this.data = Arrays.stream(s.trim().split("\\s+"))
                .mapToInt(Integer::parseInt)
                .toArray();
        this.cost = 0;
    }

    /**
     * Private constructor used internally to create successor (child) states.
     *
     * @param data The new array configuration for the child.
     * @param cost The cost of the single swap that created this child state.
     */
    private ArrayCfg(int[] data, int cost) {
        this.data = data; // Assumes the caller provides a new array instance.
        this.cost = cost;
    }

    /**
     * Generates all unique successor states (children) from the current state.
     * <p>
     * The successors are generated by swapping every unique pair of integers in the array.
     * The order of generation follows the assignment's specification: the first element
     * is swapped with all elements to its right, then the second element with all elements
     * to its right, and so on.
     *
     * @return A list of child layouts. The list is unmodifiable to preserve immutability.
     */
    @Override
    public List<Ilayout> children() {
        int n = data.length;
        if (n < 2) return Collections.emptyList();

        // Pre-allocate list capacity for performance. The number of unique swaps is n*(n-1)/2.
        List<Ilayout> children = new ArrayList<>(n * (n - 1) / 2);

        // Generate all unique swaps in the specified order.
        for (int i = 0; i < n - 1; i++)
        {
            for (int j = i + 1; j < n; j++)
            {
                // Create a defensive copy of the data array to ensure the parent state remains immutable.
                int[] childData = Arrays.copyOf(data, n);

                // Perform the swap in the new child's array.
                int tmp = childData[i];
                childData[i] = childData[j];
                childData[j] = tmp;

                // Calculate the cost of this specific swap based on the parent's values.
                int swapCost = calculateCost(data[i], data[j]);

                // Create and add the new child state to the list.
                children.add(new ArrayCfg(childData, swapCost));
            }
        }

        // Return an unmodifiable view of the list to enforce immutability.
        return Collections.unmodifiableList(children);
    }

    /**
     * Calculates the cost of swapping two integers based on their parity.
     * <ul>
     *   <li>Swapping two even integers: cost 2</li>
     *   <li>Swapping two odd integers: cost 20</li>
     *   <li>Swapping one even and one odd integer: cost 11</li>
     * </ul>
     *
     * @param a The first integer.
     * @param b The second integer.
     * @return The calculated cost of the swap.
     */
    private static int calculateCost(int a, int b) {
        // Explicitly define 0 as even. For other numbers, use bitwise AND for an efficient parity check
        // that works correctly for both positive and negative integers.
        boolean aEven = (a == 0) || ((a & 1) == 0);
        boolean bEven = (b == 0) || ((b & 1) == 0);

        if (aEven == bEven) { // Both have the same parity
            return aEven ? 2 : 20; // If aEven is true, both are even (cost 2), else both are odd (cost 20)
        } else { // Mixed parity
            return 11;
        }
    }

    /**
     * Checks if the current layout is the goal layout.
     *
     * @param l The layout to compare against.
     * @return {@code true} if the layouts are identical, {@code false} otherwise.
     */
    @Override
    public boolean isGoal(Ilayout l) {
        if (l == null || getClass() != l.getClass()) return false;
        return Arrays.equals(this.data, ((ArrayCfg) l).data);
    }

    /**
     * Gets the cost of the single step (swap) that produced this layout.
     * For the initial state, this cost is 0.
     *
     * @return The cost of the last move.
     */
    @Override
    public double getK() {
        return  this.cost;
    }

    /**
     * Calculates the heuristic value (h) for the A* algorithm.
     * <p>
     * This is a highly sophisticated and admissible heuristic that provides a very tight lower-bound
     * estimate of the cost to sort the array. It uses a hybrid strategy based on the mathematical
     * concept of <b>permutation cycle decomposition</b>, making the A* search extremely efficient.
     * The calculation involves the following steps:
     * </p>
     * <ol>
     *   <li><b>Mapping:</b> It first determines the target position for each element in the current
     *       layout relative to the goal layout, correctly handling duplicate numbers.</li>
     *   <li><b>Cycle Decomposition:</b> The permutation is broken down into disjoint cycles. For example,
     *       if element `A` is in `B`'s spot, `B` in `C`'s spot, and `C` in `A`'s spot, they form a 3-cycle.</li>
     *   <li><b>Hybrid Cost Calculation:</b> The cost for resolving each cycle is estimated based on its size:
     *     <ul>
     *       <li><b>2-Cycles:</b> The exact cost of the single swap required is calculated.</li>
     *       <li><b>Small Cycles (3-5 elements):</b> A brute-force search is performed to find the
     *           <em>true optimal cost</em> to resolve the cycle. It explores all possible sequences of `k-1`
     *           swaps within the cycle's elements.</li>
     *       <li><b>Large Cycles (>5 elements):</b> To avoid combinatorial explosion, a fast and admissible
     *           greedy estimation is used. The elements from all large cycles are pooled, and the cost
     *           is estimated by repeatedly simulating the cheapest possible swap type (even-even, etc.).</li>
     *     </ul>
     *   </li>
     * </ol>
     * <p>
     * This heuristic remains <b>admissible</b> because it calculates the exact or optimal cost for small
     * subproblems and uses a conservative, best-case greedy estimate for larger ones. At no point does
     * it overestimate the true minimum cost.
     * </p>
     * <ul>
     *     <li><b>Time Complexity:</b> O(n), where n is the number of elements in the array. Each step
     *     (mapping, cycle decomposition, greedy pairing) is linear.</li>
     *     <li><b>Space Complexity:</b> O(n), due to the storage required for the position maps and visited arrays.</li>
     * </ul>
     *
     * @param goal The goal layout to compare against.
     * @return The estimated cost to reach the goal.
     */
    @Override
    public double getH(Ilayout goal) {
        if (!(goal instanceof ArrayCfg)) return Double.POSITIVE_INFINITY;
        ArrayCfg goalCfg = (ArrayCfg) goal;

        int n = data.length;
        if (goalCfg.data.length != n) return Double.POSITIVE_INFINITY;

        // 1) Pos map (goal value -> queue of positions)
        Map<Integer, ArrayDeque<Integer>> posMap = buildPosMap(goalCfg);

        // 2) targetIndex (for each i, where data[i] must go in goal)
        int[] targetIndex = buildTargetIndex(posMap);

        // 3) decompose cycles and compute heuristic contributions
        CycleProcessResult result = processCycles(targetIndex, goalCfg);

        // 4) handle aggregated fallback (cycles > 5)
        double heuristic = result.heuristic
                + greedyCostForFallback(result.totalSwapsNeededFallback, result.evenRemFallback, result.oddRemFallback);

        return heuristic;
    }

    /* -------------------- Helper private methods -------------------- */

    private Map<Integer, ArrayDeque<Integer>> buildPosMap(ArrayCfg goalCfg) {
        int n = goalCfg.data.length;
        Map<Integer, ArrayDeque<Integer>> posMap = new HashMap<>(n * 2);
        for (int j = 0; j < n; j++) {
            posMap.computeIfAbsent(goalCfg.data[j], k -> new ArrayDeque<>()).addLast(j);
        }
        return posMap;
    }

    private int[] buildTargetIndex(Map<Integer, ArrayDeque<Integer>> posMap) {
        int n = data.length;
        int[] targetIndex = new int[n];
        for (int i = 0; i < n; i++) {
            ArrayDeque<Integer> q = posMap.get(data[i]);
            if (q == null || q.isEmpty()) {
                // multisets differ -> unreachable mapping
                // preserve previous behaviour: return an invalid mapping that will be handled by caller
                throw new IllegalArgumentException("Data and goal multisets differ");
            }
            targetIndex[i] = q.removeFirst();
        }
        return targetIndex;
    }

    /**
     * Processa os ciclos da permutação targetIndex e retorna:
     * - soma das contribuições determinísticas (2-cycles e ciclos k<=5)
     * - dados agregados para fallback (ciclos > 5)
     */
    private CycleProcessResult processCycles(int[] targetIndex, ArrayCfg goalCfg) {
        int n = data.length;
        boolean[] visited = new boolean[n];
        double heuristic = 0.0;

        int totalSwapsNeededFallback = 0;
        int evenRemFallback = 0;
        int oddRemFallback = 0;

        for (int i = 0; i < n; i++) {
            if (visited[i] || targetIndex[i] == i) {
                visited[i] = true;
                continue;
            }

            // collect cycle positions and values
            int cur = i;
            ArrayList<Integer> cycleVals = new ArrayList<>();
            ArrayList<Integer> cycleGoalVals = new ArrayList<>();

            while (!visited[cur]) {
                visited[cur] = true;
                cycleVals.add(data[cur]);
                cycleGoalVals.add(goalCfg.data[cur]);
                cur = targetIndex[cur];
            }

            int k = cycleVals.size();
            if (k <= 1) continue;

            if (k == 2) {
                // exact cost for 2-cycle
                heuristic += calculateCost(cycleVals.get(0), cycleVals.get(1));
            } else if (k <= 5) {
                // exact (enumeration) for small cycles
                heuristic += costForSmallCycle(cycleVals, cycleGoalVals);
            } else {
                // aggregate counts for fallback greedy
                int evenCount = 0, oddCount = 0;
                for (int v : cycleVals) {
                    boolean ev = (v == 0) || ((v & 1) == 0);
                    if (ev) evenCount++; else oddCount++;
                }
                totalSwapsNeededFallback += (k - 1);
                evenRemFallback += evenCount;
                oddRemFallback += oddCount;
            }
        }

        return new CycleProcessResult(heuristic, totalSwapsNeededFallback, evenRemFallback, oddRemFallback);
    }

    /**
     * Bruteforce (with light pruning) the minimal cost to reorder the cycle values into cycleGoalVals
     * using exactly (k-1) swaps among the k positions. Assumes k in [3..5].
     */
    private double costForSmallCycle(List<Integer> cycleVals, List<Integer> cycleGoalVals) {
        final int k = cycleVals.size();
        // build pair list of unordered index pairs
        ArrayList<int[]> pairList = new ArrayList<>();
        for (int a = 0; a < k - 1; a++) {
            for (int b = a + 1; b < k; b++) {
                pairList.add(new int[]{a, b});
            }
        }

        int steps = k - 1;
        int base = pairList.size();
        long sequences = 1;
        for (int s = 0; s < steps; s++) sequences *= base; // <= 10_000 for k=5

        double bestCost = Double.POSITIVE_INFINITY;
        int[] idx = new int[steps];

        for (long seq = 0; seq < sequences; seq++) {
            // simulate
            int[] curVals = new int[k];
            for (int t = 0; t < k; t++) curVals[t] = cycleVals.get(t);

            double costSum = 0.0;
            boolean pruned = false;
            for (int step = 0; step < steps; step++) {
                int pairIndex = idx[step];
                int p = pairList.get(pairIndex)[0];
                int q = pairList.get(pairIndex)[1];

                int va = curVals[p], vb = curVals[q];
                costSum += calculateCost(va, vb);

                // swap
                int tmp = curVals[p]; curVals[p] = curVals[q]; curVals[q] = tmp;

                if (costSum >= bestCost) { pruned = true; break; }
            }

            if (!pruned) {
                boolean matches = true;
                for (int t = 0; t < k; t++) {
                    if (curVals[t] != cycleGoalVals.get(t)) { matches = false; break; }
                }
                if (matches && costSum < bestCost) bestCost = costSum;
            }

            // increment mixed-radix index
            for (int p = steps - 1; p >= 0; p--) {
                idx[p]++;
                if (idx[p] < base) break;
                idx[p] = 0;
            }
        }

        if (bestCost == Double.POSITIVE_INFINITY) {
            // fallback conservative greedy pairing (should be rare)
            int even = 0, odd = 0;
            for (int v : cycleVals) { if ((v == 0) || ((v & 1) == 0)) even++; else odd++; }
            int swapsNeeded = k - 1;
            double sum = 0;
            for (int s = 0; s < swapsNeeded; s++) {
                if (even >= 2) { sum += 2; even -= 2; }
                else if (even >= 1 && odd >= 1) { sum += 11; even -= 1; odd -= 1; }
                else if (odd >= 2) { sum += 20; odd -= 2; }
                else break;
            }
            return sum;
        }

        return bestCost;
    }

    /**
     * Greedy cost to consume aggregated swapsNeeded using even/odd counts.
     * Returns the added cost.
     */
    private double greedyCostForFallback(int swapsNeeded, int evenCount, int oddCount) {
        double cost = 0.0;
        for (int s = 0; s < swapsNeeded; s++) {
            if (evenCount >= 2) {
                cost += 2; evenCount -= 2;
            } else if (evenCount >= 1 && oddCount >= 1) {
                cost += 11; evenCount -= 1; oddCount -= 1;
            } else if (oddCount >= 2) {
                cost += 20; oddCount -= 2;
            } else {
                break; // conservative
            }
        }
        return cost;
    }

    /* -------------------- Small helper types -------------------- */
    private static final class CycleProcessResult {
        final double heuristic;
        final int totalSwapsNeededFallback;
        final int evenRemFallback;
        final int oddRemFallback;
        CycleProcessResult(double heuristic, int totalSwapsNeededFallback, int evenRemFallback, int oddRemFallback) {
            this.heuristic = heuristic;
            this.totalSwapsNeededFallback = totalSwapsNeededFallback;
            this.evenRemFallback = evenRemFallback;
            this.oddRemFallback = oddRemFallback;
        }
    }

    /* --------^^---------- Helper private methods -------^^----------- */

    /**
     * Returns a string representation of the layout.
     * The integers are separated by a single space.
     *
     * @return A space-separated string of the array's contents.
     */
    @Override
    public String toString() {
        return Arrays.stream(data)
                .mapToObj(String::valueOf)
                .collect(Collectors.joining(" "));
    }

    /**
     * Compares this layout with another object for equality.
     * Two {@code ArrayCfg} objects are considered equal if their underlying integer arrays
     * have the same content in the same order.
     *
     * @param o The object to compare with.
     * @return {@code true} if the objects are equal, {@code false} otherwise.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ArrayCfg other = (ArrayCfg) o;
        return Arrays.equals(this.data, other.data);
    }

    /**
     * Returns a hash code for this layout.
     * The hash code is based on the contents of the integer array, making it consistent
     * with the {@link #equals(Object)} method.
     *
     * @return The hash code for this layout.
     */
    @Override
    public int hashCode() {
        return Arrays.hashCode(data);
    }
}
